var Address = require("Address.js");
var Bool = require("Bool.js");
var Bytes = require("Bytes.js");
var Enum = require("Enum.js");
var Int = require("Int.js");
var Storage = require("Storage.js");
var Transaction = require("Transaction.js");

module.exports = Contract;

var Contract = function(address, abi, symtab) {
    this.balance = new Int(0);
    this.nonce = new Int(0);

    switch (arguments.length) {
    case 0:
        this.address = null;
        break;
    case 1:
        this.privateKey = new Buffer(address, 'hex');// This may need to be secured
        var addrBuf = utils.privateToAddress(this.privateKey);
        this.address = new Address(addrBuf.toString('hex'));
        this.sync = syncAccount.bind(this);
        break;
    case 3:
        this.address = new Address(address);
        this.vars = {};
        //this.funcs = {};
        this._storage = new Storage();

        this.makeCall = makeFunctionCall.bind(this);
        this.sync = syncContract.bind(this);
        setVars.bind(this)(symtab);
        break;
    }
}

var makeFunctionCall = function(functionName, args) { // previously functionNameToData
    var matchesFunctionName = function(json) {
        return (json.name === functionName && json.type === "function");
    }

    var getTypes = function(json) {
        return json.type;
    }

    var funcJson = abi.filter(matchesFunctionName)[0];
    var types = (funcJson.inputs).map(getTypes);

    var fullName = functionName + '(' + types.join() + ')';
    var signature = CryptoJS.SHA3(fullName, { outputLength: 256 }).toString(CryptoJS.enc.Hex).slice(0, 8);
    var dataHex = signature + Web3Coder.encodeParams(types, args);

    return dataHex;
}

var syncContract = function(apiURL, f) {
    var done = false;
    var doCallbackWhenDone = function () {
        if (done) {
            f();
        }
        else {
            done = true;
        }
    }

    this._storage.sync(
        apiURL,
        function() {setVars.bind(this)(symtab); doCallbackWhenDone();}
    );
    syncAccount(apiURL, doCallbackWhenDone).bind(this);
}

var syncAccount = function(apiURL, f) {
    queryAPI(apiURL + "/query/account?address=" + address,
             setBalanceAndNonce.bind(this), f);
}

var setBalanceAndNonce = function(accountQueryResponse) {
    var firstAccount = accountQueryResponse[0];
    this.balance = firstAccount.balance;
    this.nonce   = firstAccount.nonce;
}

var setVars = function(symtab) {
    for (var sym in symtab) {
        // Skip type declarations
        if (symtab[sym]["atStorageKey"] !== undefined) {
            this.vars[sym] = handleVar.bind(this)(symtab[sym]);
        }
    }
}

var handleVar = function(symRow) {
    if (symRow["arrayLength"] !== undefined) {
        return handleFixedArray.bind(this)(symRow);
    }
    if (symRow["arrayDataStart"] !== undefined) {
        return handleDynamicArray.bind(this)(symRow);
    }
    if (symRow["mappingValue"] !== undefined) {
        return handleMapping.bind(this)(symRow);
    }

    var typeName = symRow["solidityType"];
    if (symtab[typeName] === undefined) {
        return handleSimpleType.bind(this)(symRow);
    }

    var typeSymTab = symtab[typeName];
    if (typeSymTab["enumNames"] != undefined) {
        var enumNames = typeSymTab["enumNames"];
        return handleSimpleType.bind(this)(symRow,typeSymTab["enumNames"]);
    }
    if (typeSymTab["structFields"] !== undefined) {
        var structFields = typeSymTab["structFields"];
        return handleStruct.bind(this)(symRow, structFields);
    }
}

var handleFixedArray = function(symRow) {
    var eltRow = Object.assign({},symRow["arrayElement"]);
    eltRow["atStorageKey"] = symRow["atStorageKey"];
    eltRow["atStorageOffset"] = "0x0";

    var eltSize = parseInt(eltRow["bytesUsed"],16);
    var numElts = parseInt(symRow["arrayLength"],16);

    var arrayCR = parseInt(symRow["arrayNewKeyEach"],16);
    var arrayCRSkip = (eltSize.lt(32) ? 1 : eltSize.over(32));

    var result = [];
    while (result.length < numElts) {
        result.push(handleVar.bind(this)(eltRow));
        if (result.length % arrayCR == 0) {
            var oldKey = new Int(eltRow["atStorageKey"]);
            eltRow["atStorageKey"] = oldKey.plus(arrayCRSkip).toString(16);
            eltRow["atStorageOffset"] = "0x0";
        }
        else {
            var oldOff = asInt(eltRow["atStorageOffset"]);
            eltRow["atStorageOffset"] = eltSize.plus(oldOff).toString(16);
        }
    }


    return result;
}
var handleDynamicArray = function(symRow) {
    var key = symRow["atStorageKey"];
    var length = this._storage.atKey(key).join("");
    var realKey = symRow["arrayDataStart"];

    if (symRow["arrayElement"] !== undefined) {
        var fixedArrayRow = Object.assign({},symRow);
        fixedArrayRow["atStorageKey"] = realKey;
        fixedArrayRow["arrayLength"] = length;
        delete fixedArrayRow["arrayDataStart"];
        return handleFixedArray.bind(this)(fixedArrayRow);
    }
    else {
        length = parseInt(length,16);
        var numSlots = length / 32;
        var rawData = this._storage.chunk(realKey,numSlots);
        var stringData = [].concat.apply([],rawData).join("");
        if (symRow["solidityType"] == "bytes") {
            return new Bytes(stringData);
        }
        if (symRow["solidityType"] == "string") {
            return utf8.decode(stringData.join(""));
        }
        return null; // I think that's it
    }
}

var handleMapping = function(symRow) {
    return var = function (x) {
        var canonKeyAt = exports.hexStringAs64Nibbles(symRow["atStorageKey"]).join("");
        var key = CryptoJS.SHA3(x.toString(16) + canonKeyAt).toString(CryptoJS.enc.Hex);
        var eltRow = Object.assign({},symRow["mappingValue"]);
        eltRow["storageKeyAt"] = key;
        return handleVar.bind(this)(eltRow);
    }
}

var handleSimpleType = function(symRow) {
    var symKey = symRow["atStorageKey"]
    var symOffset = (symRow["atStorageOffset"] === undefined) ?
        "0x0" : symRow["atStorageOffset"];
    var intOffset = parseInt(symOffset,16);
    var intBytes = parseInt(symRow["bytesUsed"],16);

    // The reversing is an expedient way of dealing with big-endianness
    var nibbles = this._storage.atKey(symKey).slice(0).reverse();
    var usedNibbles = nibbles.slice(2*intOffset, 2*(intOffset + intBytes)).reverse();
    var prefix =
        arguments[1] === undefined ?
        symRow["solidityType"].split(/\d+/)[0] :
        "enum";

    switch (prefix) {
    case 'bool' :
        return new Bool(parseInt(usedNibbles.join(""),16) != 0);
    case 'address' :
        return new Address(usedNibbles.join(""));
    case 'uint':
        return new Int(usedNibbles.join(""));
    case 'int':
        var asUInt = new Int(usedNibbles.join(""));
        var bitSize = parseInt(symRow["bytesUsed"],16) * 8;
        var topBitInt = asUInt.and(Int("1", intBytes).shiftLeft(bitSize - 1));
        return asUInt.minus(topBitInt).minus(topBitInt); // 2's complement
    case 'bytes':
        return new Bytes(usedNibbles.join(""));
    case 'enum':
        return new Enum(usedNibbles.join(""), arguments[1]);
    // case 'real': case 'ureal':
    default:
        return null; // This includes contract types, which we don't support
    }
}

var handleStruct = function(baseKey, structFields) {
    var result = {};
    for (var field in structFields) {
        var fieldRow = Object.assign({},structFields[field]);
        var fieldKey = asInt(fieldRow["atStorageKey"]);
        var realKey = baseKey.plus(fieldKey);
        fieldRow["atStorageKey"] = realKey.toString(16);
        result[field] = handleVar.bind(this)(fieldRow);
    }

    return result;
}

// var handleReal = function (symRow, usedNibbles, prefix) {
//     var precision = parseInt(symRow["solidityType"].split(/\D+/,16)[-1]);
//     var denom = BigNum(2).pow(precision);
//     var numer = BigNum(usedNibbles.join(""));

//     switch(prefix) {
//     case "ureal":
//         return numer.over(denom);
//     case "real":
//         var bitSize = 8*parseInt(symRow["bytesUsed"],16);
//         var topBitInt = bigNum(2).pow(bitSize - 1);
//         var asInt = numer;
//         if (asInt.gte(topBitInt)) {
//             asInt = asInt.minus(topBitInt).minus(topBitInt);
//         }
//         return asInt.over(denom);
//     default:
//         return null; // I don't think there is anything else, though
//     }
// }
